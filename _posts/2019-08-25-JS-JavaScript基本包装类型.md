---
layout:     post
title:      JS-JavaScript基本包装类型
subtitle:   JavaScript
date:       2019-08-25
author:     listen_spacer
header-img: img/background4.jpg
catalog: true
tags:
    - JavaScript
---
## JavaScript基本包装类型
为了便于操作基本数据类型值，ECMAScript还提供了3个特殊的引用类型：**Boolean**、**Number**和**String**。

>它们具有与各自的基本类型相应的特殊行为。
>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。

```
从内存中读取基本类型值时，后台都会自动完成下列处理：
1、创建String类型的一个实例
2、在实例上调用指定的方法
3、销毁这个实例
经过此番处理，基本的字符串值就变得跟对象一样了。
```


>引用类型与基本包装类型的主要区别就是对象的生存期。
>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。
>这意味着我们不能在运行时为基本类型值添加属性和方法。


>可以显示地调用Boolean、Number和String来创建基本包装类型地对象。
>
>Object构造函数也会像工厂方法一样，根据传入值地类型返回相应基本包装类型地实例。

```
要注意地是，使用new调用基本包装类型构造函数，与直接调用同名地转型函数是不一样地。
转型函数地变量中保存的是基本数据类型地值，而构造函数地变量中保证地是数据地实例。
```


#### Number类型：

>与Boolean类型一样，Number类型也重写了**valueOf()** 、**toLocaleString()** 和 **toString()** 方法。
>**valueOf()** 方法返回对象表示地基本类型地数值，另外两个方法则返回字符串形式数值。

>除了继承地方法之外，Number类型还提供了一些用于将数值格式化为字符串地方法。
>其中，**toFixed()** 方法会按照指定地小数位返回数值地字符串表示。

>另外可用于格式化数值地方法是 **toExponential()** ，该方法返回以指数表示法(也称e表示法)表示地数值地字符串地形式。
>这个方法也接受一个参数，该参数同样也是指定输出结果中地小数位数。

> **toPrecision()** 方法，该方法接受一个参数，即表示数值的所有数字的位数。
>    var num = 99;
>    num.toPrecision(1);		// "1e+2"
>    num.toPrecision(2);		// "99"
>    num.toPrecision(3);		// "99.0"
>实际上，toPrecision()会根据要处理的数值决定到底是调用toFixed()还是调用toExponential()


#### String类型：

**1、字符方法**
>    charAt(n)，返回值是一个字符
>    charCodeAt(n)，返回值是字符编码		n从0开始

    
```
ECMAScript5还定义了另一个访问个别字符的方法。
    在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。
    如：
        var stringvalue = "hello world";
        alert(stringvalue)		// "e"
```
**2、字符串操作方法**
>    **concat()** ，返回一个字符串，用于将一个或多个字符串拼接起来。（并不会改变字符串本身的值）
>    **slice()** 、**substr()** 和**subString()**

   
```
 在传递给这三个方法的参数是负值的情况下，它们的行为就不仅想通了。
    slice()方法会将传入的复制与字符串的长度相加；
    substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0；
    subString()方法会把所有负值参数都转换为0，并且这个方法会将较小的数作为开始位置，将较大的数作为结束位置，因此subString(3,0)会被转化成subString(0,3)。
```
**3、字符串位置方法**
>    **indexOf()** 和**lastindexOf()**
>    这两个方法都可以接受可选的第二个参数，表示从字符串中的那个位置开始搜索。

**4、trim()方法**
>    这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。
>    Firefox 3.5+、Safari 5+和Chrome 8+还支持非标准的**trimLeft()** 和**trimRight()** 方法，分别用于删除字符串开头和末尾的空格。

**5、字符串大小写转换方法**
>    **toLowerCase()** 方法和 **toUpperCase()** 方法
>    **toLocaleLowerCase()** 方法和 **toLocaleUpperCase()** 方法，这两个方法是针对特定地区实现的。
>    一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。

**6、字符串的模式匹配方法**
>    1、**match()** 方法
>        在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。
>        match()只接受有一个参数，正则表达式或者RegExp对象
>        // 与pattern.exec(text)相同
>        text.match(pattern);
>        返回值是一个数组（捕获组）。
>    2、**search()** 方法
>        参数与match()方法相同。
>        返回值是字符串种第一个匹配项的索引，如果不匹配，返回-1。
>    3、**replace()** 方法
>        两个参数：RegExp对象/字符串，字符串/函数
>        第二参数替换掉第一个参数
>        当第二参数是函数时，需要向这个函数传递三个参数，模式的匹配项，模式匹配项在字符串中的位置和原始字符串。
>    4、 **split()** 方法
>        基于指定的分隔符将一个字符串分割成多个字符串，并将结果放在一个数组中。
>        分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）
>        split()方法可以接受可选的第二个参数用于指定数组的大小，以便确保返回的数组不会超过既定大小。

**7、 **localeCompare()** 方法**
>    这个方法比较两个字符串，并返回下列值中的一个。
>    1) 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视情况而定）
>    2) 如果字符串等于字符串参数，则返回0。
>    3) 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视情况而定）

**8、 **fromCharCode()** 方法**
>    String构造函数本身的静态方法。
>    这个方法的任务是接受一个或多个字符编码，然后将他们转换成一个字符串。
>    这个方法与实例方法charCodeAt()方法执行的是相反的操作。
